public Icon GetAppIcon(IntPtr hwnd)
{
  IntPtr iconHandle = SendMessage(hwnd,WM_GETICON,ICON_SMALL2,0);
  if(iconHandle == IntPtr.Zero)
    iconHandle = SendMessage(hwnd,WM_GETICON,ICON_SMALL,0);
  if(iconHandle == IntPtr.Zero)
    iconHandle = SendMessage(hwnd,WM_GETICON,ICON_BIG,0);
  if (iconHandle == IntPtr.Zero)
    iconHandle = GetClassLongPtr(hwnd, GCL_HICON);
  if (iconHandle == IntPtr.Zero)
    iconHandle = GetClassLongPtr(hwnd, GCL_HICONSM);
 
  if(iconHandle == IntPtr.Zero)
    return null;
 
  Icon icn = Icon.FromHandle(iconHandle);
 
  return icn;
}
The constants and other methods used:

public const int GCL_HICONSM = -34;
public const int GCL_HICON = -14;
 
public const int ICON_SMALL = 0;
public const int ICON_BIG = 1;
public const int ICON_SMALL2 = 2;
 
public const int WM_GETICON = 0x7F;
 
public static IntPtr GetClassLongPtr(IntPtr hWnd, int nIndex)
{
  if (IntPtr.Size > 4)
    return GetClassLongPtr64(hWnd, nIndex);
  else
    return new IntPtr(GetClassLongPtr32(hWnd, nIndex));
}
 
[DllImport("user32.dll", EntryPoint = "GetClassLong")]
public static extern uint GetClassLongPtr32(IntPtr hWnd, int nIndex);
 
[DllImport("user32.dll", EntryPoint = "GetClassLongPtr")]
public static extern IntPtr GetClassLongPtr64(IntPtr hWnd, int nIndex);
 
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
static extern IntPtr SendMessage(IntPtr hWnd, int Msg, int wParam, int lParam);




------------------------------------------------------------------------------------------------------------------------

Process Name from hwnd
......................
Retrieve the window's process with GetWindowThreadProcessId.
Open the process with PROCESS_QUERY_INFORMATION and PROCESS_VM_READ access rights using OpenProcess.
Use GetModuleFileNameEx on the process handle.
If you really want to obtain the name of the module with which the window is registered (as opposed to the process executable),
you can obtain the module handle with GetWindowLongPtr with GWLP_HINSTANCE. The module handle can then be passed to the 
aforementioned GetModuleFileNameEx.


Get WIndow Title: GetWindowText
Now I can update my little focus-spy utility app to try: 
GetWindowText() if (text length == 0) SendMessageTimeout( ... WM_GETTEXT ... ); 
...just did it and it works beautifully. Thanks for sharing!


-----------------------------------------------------------------------------------------------------------------------------

Region Window
.............

Win32 Regions

A region is just a shape that can be used to receive the same messages that a normal window would receive. To apply a 
region to a window, you must first declare a region handle (HRGN), define the region with calls to CreateRectRgn, 
CreateEllipticRgn, or CreatePolygonRgn (and there are others beyond this -- see the Win32 documentation), combine your 
regions into one region with calls to CombineRgn, and then apply the final region to your window with a call to SetWindowRgn.

Because a region is an object, you should DeleteObject them when you are through with them.

Here's an example, which creates a sort of "figure 8" region, and applies it to our window (with handle hWnd):

HRGN hRegion1 = CreateEllipticRgn(0, 0  , 200, 200);
HRGN hRegion2 = CreateEllipticRgn(0, 180, 200, 200);

CombineRgn(hRegion1, hRegion1, hRegion2, RGN_OR);

SetWindowRgn(hWnd, hRegion1, true);

DeleteObject(hRegion1);
DeleteObject(hRegion2);



This code block defines two elliptical regions and combines them into a "figure 8" shape by ORing them (RGN_OR) with
 the CombineRgn function. It then applies the region to the hWnd window with a call to SetWindowRgn.

Take a look at the source. I've added a member function to the PortScannerWindow class that creates a region the same
 size and shape of the app window. Because I'll want my skin to cover the entire window, I'll need to make sure the 
 entire window is covered by this region.

The member function that does this is Regionize(). It takes no parameters, and its task is to figure out the window 
size and create the appropriate region to cover it.

Here's the definition:

// Remove title bar and prevent resizing
DWORD dwStyle = GetWindowLong(m_hWnd, GWL_STYLE);
dwStyle &= ~(WS_CAPTION|WS_SIZEBOX);
SetWindowLong(m_hWnd, GWL_STYLE, dwStyle);

// Define and set the region
HRGN hRegion = CreateRectRgn(0, 0, m_pRect->right-m_pRect->left, m_pRect->bottom-m_pRect->top);

SetWindowRgn(m_hWnd, hRegion, true);

DeleteObject(hRegion);

return TRUE;



Notice also the bit of code that retrieves the window long from our app window, and removes the WS_CAPTION and 
WS_SIZEBOX styles if they exist. Essentially we are removing the title bar and preventing the window from being 
resized by the user -- you can, of course, have skins that can be resized, but let's not make this harder than 
it need be. And the title bar doesn't do us any good, since we're laying a bitmap over it in a few minutes, so... hasta.

We call this member function from WinMain, immediately after calling Show(). This function should definitely do 
some error checking, since the calls could fail, but we'll leave that until later (so we'll have something to do 
when we tighten this thing down for release!)

(If you want to have more fun than just creating a rectangular region, change CreateRectRegion to CreateEllipticRgn 
in the function to make your window a perfect circle. Neat!)


Demo Source complete
....................
#include <windows.h>

int WINAPI WinMain(HINSTANCE hThisInstance, HINSTANCE, LPSTR, int cmdShow)
{
    WNDCLASSEX wincl;               
    wincl.hInstance = hThisInstance;
    wincl.lpszClassName = "win32app";
    wincl.lpfnWndProc = WndProc;
    wincl.style = CS_HREDRAW | CS_VREDRAW;
    wincl.cbSize = sizeof(WNDCLASSEX);
    wincl.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wincl.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    wincl.hCursor = LoadCursor(NULL, IDC_ARROW);
    wincl.lpszMenuName = 0;
    wincl.cbClsExtra = wincl.cbWndExtra = 0;
    wincl.hbrBackground = (HBRUSH)(COLOR_WINDOW);

    RegisterClassEx(&wincl);

    HWND hwnd = CreateWindowEx(0,wincl.lpszClassName,"Regions",
      WS_POPUP,500,500,200, 200,0,0,hThisInstance,0);

    ShowWindow(hwnd, cmdShow);

   MSG msg;
    while(GetMessage(&msg,0,0,0)) {
       TranslateMessage(&msg);
       DispatchMessage(&msg);
    }                      
    return msg.wParam;
}

LRESULT WINAPI WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   switch(message)
   {
      case WM_CREATE:
           {
             HRGN hRgn1 = CreateEllipticRgn(0,0,200,200);
             HRGN hRgn2 = CreateEllipticRgn(50,50,150,150);
             CombineRgn(hRgn1,hRgn1,hRgn2,RGN_XOR);
             DeleteObject(hRgn2);

             CreateWindow("button","Exit",WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            50,20,100,20,hwnd,(HMENU)100,(HINSTANCE)GetWindowLong(hwnd, GWL_HINSTANCE),0);

             SetWindowRgn(hwnd, hRgn1, 1);
           } return 0;

      case WM_COMMAND:
           if(LOWORD(wParam)==100) {
              SendMessage(hwnd, WM_CLOSE, 0, 0);
              return 0;
           } break;

     case WM_LBUTTONDOWN:
        SendMessage(hwnd,WM_NCLBUTTONDOWN,HTCAPTION,0);
        return 0;

      case WM_DESTROY:
           PostQuitMessage(0);
           return 0;

      default:                
           return DefWindowProc(hwnd, message, wParam, lParam);
   }
}


-----------------------------------------------------------------------------------------------------------------


bool setTransparency(HWND hWnd, unsigned char alpha)
{
	SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_LAYERED);
	SetLayeredWindowAttributes(hWnd, 0, alpha, LWA_ALPHA);
	return true;
}



-----------------------------------------------------------------------------------------------------------------

Beste Lösung:
.............
Create an off-screen bitmap (CreateCompatibleBitmap, CreateDIBSection) and render the icon into it with DrawIcon[Ex].
==> BGRA umwandeln in ARGB und vermutlich top-down

HBITMAP CreateBitmap32(int cx, int cy)
{
	BITMAPINFO RGB32BitsBITMAPINFO; 
	UINT *ptPixels;
	HBITMAP DirectBitmap;

	ZeroMemory(&RGB32BitsBITMAPINFO,sizeof(BITMAPINFO));
	RGB32BitsBITMAPINFO.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
	RGB32BitsBITMAPINFO.bmiHeader.biWidth=cx;//bm.bmWidth;
	RGB32BitsBITMAPINFO.bmiHeader.biHeight=cy;//bm.bmHeight;
	RGB32BitsBITMAPINFO.bmiHeader.biPlanes=1;
	RGB32BitsBITMAPINFO.bmiHeader.biBitCount=32;

	DirectBitmap = CreateDIBSection(NULL, 
					(BITMAPINFO *)&RGB32BitsBITMAPINFO, 
					DIB_RGB_COLORS,
					(void **)&ptPixels, 
					NULL, 0);
	return DirectBitmap;
}

==> Dann:
	hDC = CreateCompatibleDC(NULL);
	SelectBitmap(hDC, hbmpDib);
	DrawIcon[Ex]




HICON to ARGB
.............
Image* Icon2Image(HICON hIcon)
{
	BITMAP bm;
	ICONINFO iconInfo;
	
	GetIconInfo(hIcon, &iconInfo);
	GetObject(iconInfo.hbmColor, sizeof(BITMAP),&bm);
	
	int width = bm.bmWidth;
	int height = bm.bmHeight;
	int bytesPerScanLine = (width * 3 + 3) & 0xFFFFFFFC;
	int size = bytesPerScanLine * height;
	
	BITMAPINFO infoheader;
	infoheader.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	infoheader.bmiHeader.biWidth = width;
	infoheader.bmiHeader.biHeight = height;
	infoheader.bmiHeader.biPlanes = 1;
	infoheader.bmiHeader.biBitCount = 24;
	infoheader.bmiHeader.biCompression = BI_RGB;
	infoheader.bmiHeader.biSizeImage = size;
	
	// allocate Memory for Icon RGB data plus Icon mask plus ARGB buffer for the resulting image
	MemoryBlock* pMemBlock = new MemoryBlock((size*2+height*width*4)*sizeof(uint8));
	uint8* pixelsIconRGB = (uint8*)pMemBlock->getData();
	uint8* alphaPixels	 = (uint8*)(pixelsIconRGB+size);
	uint32* imagePixels   = (uint32*)(alphaPixels+size);
	
	HDC hDC = CreateCompatibleDC(NULL);
	
	// Get Icon RGB data
	HBITMAP hBmpOld = (HBITMAP)SelectObject(hDC, (HGDIOBJ)iconInfo.hbmColor);
	if(!GetDIBits(hDC, iconInfo.hbmColor, 0, height, (LPVOID) pixelsIconRGB, &infoheader, DIB_RGB_COLORS))
		return NULL;
	SelectObject(hDC, hBmpOld);
   
   // now get the mask
   if(!GetDIBits(hDC, iconInfo.hbmMask, 0,height,(LPVOID)alphaPixels, &infoheader, DIB_RGB_COLORS))
		return NULL;
		==> Im Fehlerfall hier nicht abbrechen, sondern  alle alphapixels = 0 setzen!
	int x=0;
	int currentSrcPos=0;
	int currentDestPos=0;
	int linePosSrc = 0;
	int linePosDest = 0;
	int lsSrc = width*3;
	int vsDest = height-1;
	for(int y=0; y<height; y++)
	{
		linePosSrc = (vsDest-y)*lsSrc;
		linePosDest = y*width;
		for(x=0; x<width; x++)
		{
			//pixels from Icon are stored in BGR vertical and horizontal flipped order
			currentDestPos = linePosDest+x;
			currentSrcPos  = linePosSrc+x*3;
			// BGR -> ARGB 
			imagePixels[currentDestPos]=(((uint32)((((pixelsIconRGB[currentSrcPos+2] << 0x10 /*Red*/) | (pixelsIconRGB[currentSrcPos+1] << 8 /*Green*/)) 
				| pixelsIconRGB[currentSrcPos] /*Blue*/) | ((alphaPixels[currentSrcPos]?0:255) << 0x18))) & 0xffffffffL);
		}
	}
	Image *pImage = new Image(Image::ARGB, width, height,true);
	pImage->setPixelData (0, 0, width, height, (uint8*)imagePixels, width*4);
	deleteAndNull(pMemBlock)
	DeleteDC(hDC);
	return pImage;
}




HICON to HBITMAP
................
HDC hDC = GetDC(NULL);
HDC hMemDC = CreateCompatibleDC(hDC);
HBITMAP hMemBmp = CreateCompatibleBitmap(hDC, x, y);
HBITMAP hResultBmp = NULL;
HGDIOBJ hOrgBMP = SelectObject(hMemDC, hMemBmp);

DrawIconEx(hMemDC, 0, 0, hIcon, x, y, 0, NULL, DI_NORMAL);

hResultBmp = hMemBmp;
hMemBmp = NULL;

SelectObject(hMemDC, hOrgBMP);
DeleteDC(hMemDC);
ReleaseDC(NULL, hDC);
DestroyIcon(hIcon);
return hResultBmp;


-----------------------------------------------------------------------------------------------------------------

Live Thumbnail Preview
......................
https://msdn.microsoft.com/en-us/library/aa969541.aspx


-----------------------------------------------------------------------------------------------------------------

d:\recording\cubase
d:\recording\samples

	@ d:\
		recording
			Cubase
			Samples
				Glassy
				Noise
		Portable Apps\jknobman


-----------------------------------------------------------------------------------------------------------------

OpenGL Transparency mit Alpha Gl-context
........................................
This is an old question, but since newer versions of Windows have compositing and support, as datenwolf hints, 
for opengl, we can use some of that special sauce for accomplishing this. Although it is also trivial with 
DirectX (go figure...) Microsoft did add compositing hints to opengl contexts. Yay anti-trust fears!

So instead of an inefficient copy-to-physical-memory action, we can have the compositing engine just understand
how to make use of the opengl context.

So, you have to create an opengl context with a pixelformat that specifies an alpha channel and that it should
use composition (line 82). Then, you use the DwmApi.h routines to enable a blurred window (line 179) with a 
completely invalid region specified, which will blur nothing and leave the window transparent. (You need to 
specify a black+transparent brush on the window class! Oddly!) Then, you actually just use opengl as you are 
used to using it. In the event loop, every chance you get, you can just draw and swap buffers (line 201) and 
remember to enable GL_BLEND! :)

Please review/fork https://gist.github.com/3644466 or just view the following code snippet based off of the OP's 
own answer with this technique instead (you can just plop this in an empty project):

#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <windowsx.h>
#include <GL/gl.h>
#include <GL/glu.h>

#include <dwmapi.h>

#pragma comment (lib, "opengl32.lib")
#pragma comment (lib, "glu32.lib")

#pragma comment (lib, "dwmapi.lib")

#include <assert.h>
#include <tchar.h>

#ifdef  assert
#define verify(expr) if(!expr) assert(0)
#else verify(expr) expr
#endif

const TCHAR szAppName[]=_T("TransparentGL");
const TCHAR wcWndName[]=_T("TransparentGL");

HDC hDC;            
HGLRC m_hrc;        
int w = 240;
int h = 240;

BOOL initSC() {
    glEnable(GL_ALPHA_TEST);        
    glEnable(GL_DEPTH_TEST);        
    glEnable(GL_COLOR_MATERIAL);

    glEnable(GL_LIGHTING);          
    glEnable(GL_LIGHT0);            

    glEnable(GL_BLEND);             
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glClearColor(0, 0, 0, 0);

    return 0;
}

void resizeSC(int width,int height) {
    glViewport(0,0,width,height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW );
    glLoadIdentity();
}

BOOL renderSC() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    glPushMatrix();

    glColor3f(0, 1, 1);
    glBegin(GL_TRIANGLES);                              // Drawing Using Triangles
        glColor3f(1.0f,0.0f,0.0f);                      // Set The Color To Red
        glVertex3f( 0.0f, 1.0f, 0.0f);                  // Top
        glColor3f(0.0f,1.0f,0.0f);                      // Set The Color To Green
        glVertex3f(-1.0f,-1.0f, 0.0f);                  // Bottom Left
        glColor3f(0.0f,0.0f,1.0f);                      // Set The Color To Blue
        glVertex3f( 1.0f,-1.0f, 0.0f);                  // Bottom Right
    glEnd();

    glPopMatrix();
    glFlush();

    return 0;
}

BOOL CreateHGLRC(HWND hWnd) {
    PIXELFORMATDESCRIPTOR pfd = {
      sizeof(PIXELFORMATDESCRIPTOR),
      1,                                // Version Number
      PFD_DRAW_TO_WINDOW      |         // Format Must Support Window
      PFD_SUPPORT_OPENGL      |         // Format Must Support OpenGL
      PFD_SUPPORT_COMPOSITION |         // Format Must Support Composition
      PFD_DOUBLEBUFFER,                 // Must Support Double Buffering
      PFD_TYPE_RGBA,                    // Request An RGBA Format
      32,                               // Select Our Color Depth
      0, 0, 0, 0, 0, 0,                 // Color Bits Ignored
      8,                                // An Alpha Buffer
      0,                                // Shift Bit Ignored
      0,                                // No Accumulation Buffer
      0, 0, 0, 0,                       // Accumulation Bits Ignored
      24,                               // 16Bit Z-Buffer (Depth Buffer)
      8,                                // Some Stencil Buffer
      0,                                // No Auxiliary Buffer
      PFD_MAIN_PLANE,                   // Main Drawing Layer
      0,                                // Reserved
      0, 0, 0                           // Layer Masks Ignored
    };     

    HDC hdc = GetDC(hWnd);
    int PixelFormat = ChoosePixelFormat(hdc, &pfd);
    if (PixelFormat == 0) {
      assert(0);
      return FALSE ;
    }

    BOOL bResult = SetPixelFormat(hdc, PixelFormat, &pfd);
    if (bResult==FALSE) {
      assert(0);
      return FALSE ;
    }

    m_hrc = wglCreateContext(hdc);
    if (!m_hrc){
      assert(0);
      return FALSE;
    }

    ReleaseDC(hWnd, hdc);

    return TRUE;
}

LRESULT CALLBACK WindowFunc(HWND hWnd,UINT msg, WPARAM wParam, LPARAM lParam) {
    PAINTSTRUCT ps;

    switch(msg) {
        case WM_CREATE:
        break;

        case WM_DESTROY:
            if(m_hrc) {
                wglMakeCurrent(NULL, NULL);
                wglDeleteContext(m_hrc) ;
            }
            PostQuitMessage(0) ;
        break;

        default: 
            return DefWindowProc(hWnd,msg,wParam,lParam);
    }

    return 0;
}

int WINAPI _tWinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst, LPSTR str,int nWinMode) {
    WNDCLASSEX wc;
    memset(&wc, 0, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = (WNDPROC)WindowFunc;
    wc.cbClsExtra  = 0;
    wc.cbWndExtra  = 0;
    wc.hInstance = hThisInst;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)CreateSolidBrush(0x00000000);
    wc.lpszClassName = szAppName;

    if(!RegisterClassEx(&wc)) {
        MessageBox(NULL, _T("RegisterClassEx - failed"), _T("Error"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    HWND hWnd = CreateWindowEx(WS_EX_APPWINDOW, szAppName, wcWndName,
                    WS_VISIBLE | WS_POPUP, 200, 150, w, h,
                    NULL, NULL, hThisInst, NULL);

    if(!hWnd) {
        MessageBox(NULL, _T("CreateWindowEx - failed"), _T("Error"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    DWM_BLURBEHIND bb = {0};
    HRGN hRgn = CreateRectRgn(0, 0, -1, -1);
    bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
    bb.hRgnBlur = hRgn;
    bb.fEnable = TRUE;
    DwmEnableBlurBehindWindow(hWnd, &bb);
    
    CreateHGLRC(hWnd);

    HDC hdc = GetDC(hWnd);
    wglMakeCurrent(hdc, m_hrc);
    initSC();
    resizeSC(w, h);
    ReleaseDC(hWnd, hdc);

    MSG msg;  
    while(1) {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else {
            HDC hdc = GetDC(hWnd);
            wglMakeCurrent(hdc, m_hrc);

            renderSC();

            SwapBuffers(hdc);
            ReleaseDC(hWnd, hdc);
        }
    } 

    return (FALSE); 
}



-----------------------------------------------------------------------------------------------------------------

OpenGL Transparency mit drawing in bitmap (ineffizient)
.......................................................
		
#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <windowsx.h>
#include <GL/gl.h>
#include <GL/glu.h>

#pragma comment (lib, "opengl32.lib")
#pragma comment (lib, "glu32.lib")

#include <assert.h>
#include <tchar.h>

#ifdef  assert
#define verify(expr) if(!expr) assert(0)
#else verify(expr) expr
#endif

const TCHAR szAppName[]=_T("TransparentGL");
const TCHAR wcWndName[]=_T("WS_EX_LAYERED OpenGL");

HDC hDC;            
HGLRC m_hrc;        
int w(240);
int h(240); 

HDC pdcDIB;                 
HBITMAP hbmpDIB;            
void *bmp_cnt(NULL);        
int cxDIB(0); 
int cyDIB(0);   
BITMAPINFOHEADER BIH;       


BOOL initSC()
{
    glEnable(GL_ALPHA_TEST);        
    glEnable(GL_DEPTH_TEST);        
    glEnable(GL_COLOR_MATERIAL);

    glEnable(GL_LIGHTING);          
    glEnable(GL_LIGHT0);            

    glEnable(GL_BLEND);             
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glClearColor(0, 0, 0, 0);

    return 0;
}

void resizeSC(int width,int height)
{
    glViewport(0,0,width,height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW );
    glLoadIdentity();
}

BOOL renderSC()
{   
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    glPushMatrix();

    glColor3f(0, 1, 1);
    glBegin(GL_TRIANGLES);                              // Drawing Using Triangles
        glColor3f(1.0f,0.0f,0.0f);                      // Set The Color To Red
        glVertex3f( 0.0f, 1.0f, 0.0f);                  // Top
        glColor3f(0.0f,1.0f,0.0f);                      // Set The Color To Green
        glVertex3f(-1.0f,-1.0f, 0.0f);                  // Bottom Left
        glColor3f(0.0f,0.0f,1.0f);                      // Set The Color To Blue
        glVertex3f( 1.0f,-1.0f, 0.0f);                  // Bottom Right
    glEnd();

    glPopMatrix();
    glFlush();

    return 0;
}

// DIB -> hDC
void draw(HDC pdcDest)
{
    assert(pdcDIB);

    verify(BitBlt(pdcDest, 0, 0, w, h, pdcDIB, 0, 0, SRCCOPY));
}

void CreateDIB(int cx, int cy)
{
    assert(cx > 0); 
    assert(cy > 0);

    cxDIB = cx ;
    cyDIB = cy ;

    int iSize = sizeof(BITMAPINFOHEADER);   
    memset(&BIH, 0, iSize);

    BIH.biSize = iSize;
    BIH.biWidth = cx;   
    BIH.biHeight = cy;  
    BIH.biPlanes = 1;   
    BIH.biBitCount = 24;    
    BIH.biCompression = BI_RGB;

    if(pdcDIB) 
        verify(DeleteDC(pdcDIB));

    pdcDIB = CreateCompatibleDC(NULL);
    assert(pdcDIB);

    if(hbmpDIB) 
        verify(DeleteObject(hbmpDIB));

    hbmpDIB = CreateDIBSection(
        pdcDIB,         
        (BITMAPINFO*)&BIH,  
        DIB_RGB_COLORS,     
        &bmp_cnt,       
        NULL,
        0);

    assert(hbmpDIB);
    assert(bmp_cnt);

    if(hbmpDIB)
        SelectObject(pdcDIB, hbmpDIB);
}

BOOL CreateHGLRC()
{
    DWORD dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_BITMAP;

    PIXELFORMATDESCRIPTOR pfd ;
    memset(&pfd,0, sizeof(PIXELFORMATDESCRIPTOR)) ;
    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); 
    pfd.nVersion = 1;                       
    pfd.dwFlags =  dwFlags ;                
    pfd.iPixelType = PFD_TYPE_RGBA ;        
    pfd.cColorBits = 24 ;                   
    pfd.cDepthBits = 32 ;                   
    pfd.iLayerType = PFD_MAIN_PLANE ;       

   int PixelFormat = ChoosePixelFormat(pdcDIB, &pfd);
   if (PixelFormat == 0){
      assert(0);
      return FALSE ;
   }

   BOOL bResult = SetPixelFormat(pdcDIB, PixelFormat, &pfd);
   if (bResult==FALSE){
      assert(0);
      return FALSE ;
   }

   m_hrc = wglCreateContext(pdcDIB);
   if (!m_hrc){
      assert(0);
      return FALSE;
   }

   return TRUE;
}

LRESULT CALLBACK WindowFunc(HWND hWnd,UINT msg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;

    switch(msg) 
    {
        case WM_ERASEBKGND:
            return 0;
        break;

        case WM_CREATE:
        break;

        case WM_DESTROY:
            if(m_hrc)
            {
                wglMakeCurrent(NULL, NULL);
                wglDeleteContext(m_hrc) ;
            }
            PostQuitMessage(0) ;
        break;

        case WM_PAINT:
            hDC = BeginPaint(hWnd, &ps);
            renderSC(); // OpenGL -> DIB
            draw(hDC);  // DIB -> hDC
            EndPaint(hWnd, &ps);
        break;

        case WM_SIZE:
            w = LOWORD(lParam); h = HIWORD(lParam);         
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(m_hrc);

            CreateDIB(w, h);
            CreateHGLRC();
            verify(wglMakeCurrent(pdcDIB, m_hrc));

            initSC();
            resizeSC(w, h);
            renderSC();
        break;

        default: 
            return DefWindowProc(hWnd,msg,wParam,lParam);
    }

    return 0;
}

int WINAPI _tWinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst, LPSTR str,int nWinMode)
{   
    WNDCLASSEX wc;
    memset(&wc, 0, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = (WNDPROC)WindowFunc;
    wc.cbClsExtra  = 0;
    wc.cbWndExtra  = 0;
    wc.hInstance = hThisInst;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW);
    wc.lpszClassName = szAppName;

    if(!RegisterClassEx(&wc))
    {
        MessageBox(NULL, _T("RegisterClassEx - failed"), _T("Error"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    HWND hWnd = CreateWindowEx(WS_EX_LAYERED, szAppName, wcWndName,
                    WS_VISIBLE | WS_POPUP, 200, 150, w, h,
                    NULL, NULL, hThisInst, NULL);
    if(!hWnd){
        MessageBox(NULL, _T("CreateWindowEx - failed"), _T("Error"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    verify(SetLayeredWindowAttributes(hWnd, 0x0, 0, LWA_COLORKEY));

    MSG msg;
    while(1) 
    {
        while (PeekMessage(&msg,NULL,0,0,PM_NOREMOVE)){
            if (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else return 0;
        }
    } 

    return (FALSE); 
}
